import connexion
from typing import Dict
from typing import Tuple
from typing import Union

{{#imports}}{{import}}  # noqa: E501
{{/imports}}
# from {{packageName}} import util  # Not used
{{#operations}}
{{#operation}}


def {{operationId}}({{#allParams}}{{^isBodyParam}}{{paramName}}{{/isBodyParam}}{{#isBodyParam}}body{{/isBodyParam}}{{^required}}=None{{/required}}{{^-last}}, {{/-last}}{{/allParams}}):  # noqa: E501
    """{{summary}}{{^summary}}{{operationId}}{{/summary}}

    {{notes}} # noqa: E501

    {{#allParams}}
    :param {{paramName}}: {{description}}
        {{^isContainer}}
            {{#isPrimitiveType}}
    :type {{paramName}}: {{>param_type}}
            {{/isPrimitiveType}}
            {{#isUuid}}
    :type {{paramName}}: {{>param_type}}
            {{/isUuid}}
            {{^isPrimitiveType}}
                {{#isFile}}
    :type {{paramName}}: werkzeug.datastructures.FileStorage
                {{/isFile}}
                {{^isFile}}
                    {{^isUuid}}
    :type {{paramName}}: dict | bytes
                    {{/isUuid}}
                {{/isFile}}
            {{/isPrimitiveType}}
        {{/isContainer}}
        {{#isArray}}
            {{#items}}
                {{#isPrimitiveType}}
    :type {{paramName}}: List[{{>param_type}}]
                {{/isPrimitiveType}}
                {{^isPrimitiveType}}
    :type {{paramName}}: list | bytes
                {{/isPrimitiveType}}
            {{/items}}
        {{/isArray}}
        {{#isMap}}
            {{#items}}
                {{#isPrimitiveType}}
    :type {{paramName}}: Dict[str, {{>param_type}}]
                {{/isPrimitiveType}}
                {{^isPrimitiveType}}
    :type {{paramName}}: dict | bytes
                {{/isPrimitiveType}}
            {{/items}}
        {{/isMap}}
    {{/allParams}}

    :rtype: Union[{{returnType}}{{^returnType}}None{{/returnType}}, Tuple[{{returnType}}{{^returnType}}None{{/returnType}}, int], Tuple[{{returnType}}{{^returnType}}None{{/returnType}}, int, Dict[str, str]]
    """
    # Auto-generated parameter handling
    {{#allParams}}
        {{#isBodyParam}}
    {{#bodyParam}}
    if connexion.request.is_json:
        body = {{#dataType}}{{dataType}}.from_dict(connexion.request.get_json()){{/dataType}}{{^dataType}}connexion.request.get_json(){{/dataType}}  # noqa: E501
    {{/bodyParam}}
        {{/isBodyParam}}
        {{^isBodyParam}}
            {{^isContainer}}
                {{#isDate}}
    {{paramName}} = util.deserialize_date({{paramName}})
                {{/isDate}}
                {{#isDateTime}}
    {{paramName}} = util.deserialize_datetime({{paramName}})
                {{/isDateTime}}
            {{/isContainer}}
            {{#isArray}}
                {{#items}}
                    {{#isDate}}
    if {{paramName}}:
        {{paramName}} = [util.deserialize_date(s) for s in {{paramName}}]  # noqa: E501
                    {{/isDate}}
                    {{#isDateTime}}
    if {{paramName}}:
        {{paramName}} = [util.deserialize_datetime(s) for s in {{paramName}}]  # noqa: E501
                    {{/isDateTime}}
                {{/items}}
            {{/isArray}}
        {{/isBodyParam}}
    {{/allParams}}

    # CMZ Auto-Generated Implementation Connection
    # This template automatically connects controllers to impl modules
    try:
        # Dynamic import of implementation module based on controller name
        # Auto-detect implementation module from operationId
        impl_module_name = "{{classFilename}}".replace("_controller", "")
        impl_function_name = "handle_"

        # Try common implementation patterns
        try:
            # Pattern 1: Direct module import
            impl_module = __import__(f"{{packageName}}.impl.{impl_module_name}", fromlist=[impl_function_name])
            impl_function = getattr(impl_module, impl_function_name)
        except (ImportError, AttributeError):
            # Pattern 2: Generic handler with hexagonal architecture routing
            from {{packageName}}.impl import handlers
            # Use the generic handle_ function that routes based on caller name
            impl_function = handlers.handle_
            if not impl_function:
                # Pattern 3: Default error for missing implementation
                raise NotImplementedError(
                    f"Implementation function 'handle_' not found in handlers module. "
                    f"Please ensure the following: "
                    f"1. The handlers.py file exists in the impl directory "
                    f"2. The handle_ function is defined in handlers.py "
                    f"3. The function signature matches the controller parameters"
                )

        # Call implementation function with processed parameters
        result = impl_function({{#allParams}}{{^isBodyParam}}{{paramName}}{{/isBodyParam}}{{#isBodyParam}}body{{/isBodyParam}}{{^-last}}, {{/-last}}{{/allParams}})

        # Handle different return types
        if isinstance(result, tuple):
            return result  # Already formatted (data, status_code)
        else:
            return result, {{#responses}}{{#-first}}{{code}}{{/-first}}{{/responses}}{{^responses}}200{{/responses}}

    except NotImplementedError as e:
        # Development mode: return clear error instead of placeholder
        from {{packageName}}.models.error import Error
        error_obj = Error(
            code="not_implemented",
            message=f"Controller {{operationId}} implementation not found: {str(e)}",
            details={"controller": "{{classname}}", "operation": "{{operationId}}"}
        )
        return error_obj, 501

    except Exception as e:
        # Use centralized error handler if available
        try:
            from {{packageName}}.impl.error_handler import handle_exception_for_controllers
            return handle_exception_for_controllers(e)
        except ImportError:
            # Fallback error response
            from {{packageName}}.models.error import Error
            error_obj = Error(
                code="internal_error",
                message=f"Internal server error in {{operationId}}: {str(e)}",
                details={"controller": "{{classname}}", "operation": "{{operationId}}"}
            )
            return error_obj, 500
{{/operation}}
{{/operations}}