import connexion
{{#imports}}{{#-last}}from typing import Dict
from typing import Tuple
from typing import Union

{{/-last}}{{/imports}}{{#models}}{{#model}}from {{package}}.models.{{classFilename}} import {{classname}}{{#hasMore}}  # noqa: E501{{/hasMore}}
{{/model}}{{/models}}from {{package}} import util

{{#operations}}

{{#operation}}
def {{operationId}}({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}}):  # noqa: E501
    """{{summary}}{{#notes}}

    {{notes}}{{/notes}}

{{#allParams}}    :param {{paramName}}: {{description}}
    :type {{paramName}}: {{#isString}}str{{/isString}}{{#isLong}}int{{/isLong}}{{#isInteger}}int{{/isInteger}}{{#isBoolean}}bool{{/isBoolean}}{{#isBinary}}str{{/isBinary}}{{#isByteArray}}str{{/isByteArray}}{{#isUuid}}str{{/isUuid}}{{#isEmail}}str{{/isEmail}}{{#isFreeFormObject}}object{{/isFreeFormObject}}{{#isAnyType}}object{{/isAnyType}}{{#isDateTime}}datetime{{/isDateTime}}{{#isDate}}date{{/isDate}}{{#isFile}}str{{/isFile}}{{#isPrimitiveType}}{{#isString}}str{{/isString}}{{#isLong}}int{{/isLong}}{{#isInteger}}int{{/isInteger}}{{#isBoolean}}bool{{/isBoolean}}{{#isBinary}}str{{/isBinary}}{{#isByteArray}}str{{/isByteArray}}{{#isUuid}}str{{/isUuid}}{{#isEmail}}str{{/isEmail}}{{#isFreeFormObject}}object{{/isFreeFormObject}}{{#isAnyType}}object{{/isAnyType}}{{#isDateTime}}datetime{{/isDateTime}}{{#isDate}}date{{/isDate}}{{#isFile}}str{{/isFile}}{{/isPrimitiveType}}{{#isContainer}}{{#isArray}}List[{{#items}}{{#isPrimitiveType}}{{#isString}}str{{/isString}}{{#isLong}}int{{/isLong}}{{#isInteger}}int{{/isInteger}}{{#isBoolean}}bool{{/isBoolean}}{{/isPrimitiveType}}{{#isModel}}{{datatype}}{{/isModel}}{{/items}}]{{/isArray}}{{#isMap}}Dict[str, {{#items}}{{#isPrimitiveType}}{{#isString}}str{{/isString}}{{#isLong}}int{{/isLong}}{{#isInteger}}int{{/isInteger}}{{#isBoolean}}bool{{/isBoolean}}{{/isPrimitiveType}}{{#isModel}}{{datatype}}{{/isModel}}{{/items}}]{{/isMap}}{{/isContainer}}{{#isModel}}{{datatype}}{{/isModel}} | bytes

{{/allParams}}
    :rtype: Union[{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}None{{/returnType}}, Tuple[{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}None{{/returnType}}, int], Tuple[{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}None{{/returnType}}, int, Dict[str, str]]]
    """
{{#hasParams}}{{#allParams}}{{#-first}}    # Auto-generated parameter handling
{{/-first}}{{#hasBodyParam}}{{#isBodyParam}}    if connexion.request.is_json:
        {{paramName}} = {{dataType}}.from_dict(connexion.request.get_json())  # noqa: E501
{{/isBodyParam}}{{/hasBodyParam}}{{/allParams}}
{{/hasParams}}
    # CMZ Auto-Generated Implementation Connection
    # This template automatically connects controllers to impl modules
    try:
        # Dynamic import of implementation module based on controller name
        {{#vendorExtensions.x-impl-module}}
        from {{package}}.impl.{{vendorExtensions.x-impl-module}} import {{vendorExtensions.x-impl-function}}
        {{/vendorExtensions.x-impl-module}}
        {{^vendorExtensions.x-impl-module}}
        # Auto-detect implementation module from operationId
        impl_module_name = "{{#lambda.lowercase}}{{classname}}{{/lambda.lowercase}}".replace("_controller", "")
        impl_function_name = "handle_{{#lambda.underscore}}{{operationId}}{{/lambda.underscore}}"

        # Try common implementation patterns
        try:
            # Pattern 1: Direct module import
            impl_module = __import__(f"{{package}}.impl.{impl_module_name}", fromlist=[impl_function_name])
            impl_function = getattr(impl_module, impl_function_name)
        except (ImportError, AttributeError):
            # Pattern 2: Generic handler with hexagonal architecture routing
            from {{package}}.impl import handlers
            # Use the generic handle_ function that routes based on caller name
            impl_function = handlers.handle_
            if not impl_function:
                # Pattern 3: Default error for missing implementation
                raise NotImplementedError(f"Implementation function 'handle_' not found in handlers module")
        {{/vendorExtensions.x-impl-module}}

        # Call implementation function with processed parameters
        {{#hasParams}}
        result = impl_function({{#allParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}})
        {{/hasParams}}
        {{^hasParams}}
        result = impl_function()
        {{/hasParams}}

        # Handle different return types
        if isinstance(result, tuple):
            return result  # Already formatted (data, status_code)
        else:
            return result, {{#responses}}{{#-first}}{{code}}{{/-first}}{{/responses}}{{^responses}}200{{/responses}}

    except NotImplementedError as e:
        # Development mode: return clear error instead of placeholder
        from {{package}}.models.error import Error
        error_obj = Error(
            code="not_implemented",
            message=f"Controller {{operationId}} implementation not found: {str(e)}",
            details={"controller": "{{classname}}", "operation": "{{operationId}}"}
        )
        return error_obj, 501

    except Exception as e:
        # Use centralized error handler if available
        try:
            from {{package}}.impl.error_handler import handle_exception_for_controllers
            return handle_exception_for_controllers(e)
        except ImportError:
            # Fallback error response
            from {{package}}.models.error import Error
            error_obj = Error(
                code="internal_error",
                message=f"Internal server error in {{operationId}}: {str(e)}",
                details={"controller": "{{classname}}", "operation": "{{operationId}}"}
            )
            return error_obj, 500


{{/operation}}
{{/operations}}