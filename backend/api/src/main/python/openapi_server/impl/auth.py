"""
Implementation module for auth
Auto-generated by post_openapi_generation.py
Enhanced with environment mode support and JWT utilities
"""

import os
import boto3
from typing import Any, Dict, List, Tuple, Union, Optional
from botocore.exceptions import ClientError
from ..models.error import Error
from .utils.jwt_utils import create_auth_response, generate_jwt_token

# Environment configuration
AUTH_MODE = os.environ.get('AUTH_MODE', 'mock')
COGNITO_USER_POOL_ID = os.environ.get('COGNITO_USER_POOL_ID', '')
COGNITO_CLIENT_ID = os.environ.get('COGNITO_CLIENT_ID', '')
USERS_TABLE_NAME = os.environ.get('USERS_DYNAMO_TABLE_NAME', 'cmz-users-dev')

# Log auth mode on module load
print(f"ðŸ” Authentication Mode: {AUTH_MODE}")


def authenticate_user_mock(email: str, password: str) -> Dict[str, Any]:
    """
    Mock authentication for local development.
    Uses hardcoded test users.
    """
    # Test users for validation
    test_users = {
        'admin@cmz.org': {'password': 'admin123', 'role': 'admin'},
        'test@cmz.org': {'password': 'testpass123', 'role': 'user'},
        'parent1@test.cmz.org': {'password': 'testpass123', 'role': 'parent'},
        'student1@test.cmz.org': {'password': 'testpass123', 'role': 'student'},
        'student2@test.cmz.org': {'password': 'testpass123', 'role': 'student'},
        'user_parent_001@cmz.org': {'password': 'testpass123', 'role': 'parent'}
    }

    # Check credentials
    if email not in test_users or test_users[email]['password'] != password:
        raise ValueError("Invalid email or password")

    # Create user data
    user_data = {
        'email': email,
        'role': test_users[email]['role'],
        'user_id': email.replace('@', '_').replace('.', '_'),
        'auth_mode': 'mock'
    }

    return create_auth_response(user_data)


def authenticate_user_dynamodb(email: str, password: str) -> Dict[str, Any]:
    """
    Authenticate against DynamoDB users table.
    For staging/testing environments.
    """
    try:
        # Get user from DynamoDB
        dynamodb = boto3.resource('dynamodb')
        users_table = dynamodb.Table(USERS_TABLE_NAME)
        response = users_table.get_item(Key={'email': email})

        if 'Item' not in response:
            raise ValueError("Invalid email or password")

        user_item = response['Item']

        # Simple password check (should use hashing in production)
        if user_item.get('password') != password:
            raise ValueError("Invalid email or password")

        # Create user data
        user_data = {
            'email': email,
            'role': user_item.get('role', 'user'),
            'user_id': user_item.get('userId', email.replace('@', '_').replace('.', '_')),
            'auth_mode': 'dynamodb'
        }

        return create_auth_response(user_data)

    except ClientError as e:
        print(f"DynamoDB error: {str(e)}")
        raise ValueError("Authentication service unavailable")


def authenticate_user_cognito(email: str, password: str) -> Dict[str, Any]:
    """
    Authenticate against AWS Cognito.
    For production environments.
    """
    try:
        cognito_client = boto3.client('cognito-idp')

        # Initiate auth
        response = cognito_client.initiate_auth(
            ClientId=COGNITO_CLIENT_ID,
            AuthFlow='USER_PASSWORD_AUTH',
            AuthParameters={
                'USERNAME': email,
                'PASSWORD': password
            }
        )

        # Get user attributes
        user_response = cognito_client.get_user(
            AccessToken=response['AuthenticationResult']['AccessToken']
        )

        # Extract user attributes
        attributes = {attr['Name']: attr['Value'] for attr in user_response['UserAttributes']}

        # Create user data
        user_data = {
            'email': email,
            'role': attributes.get('custom:role', 'user'),
            'user_id': attributes.get('sub', email.replace('@', '_').replace('.', '_')),
            'auth_mode': 'cognito',
            'cognito_tokens': {
                'id_token': response['AuthenticationResult'].get('IdToken'),
                'access_token': response['AuthenticationResult'].get('AccessToken'),
                'refresh_token': response['AuthenticationResult'].get('RefreshToken')
            }
        }

        return create_auth_response(user_data)

    except ClientError as e:
        error_code = e.response['Error']['Code']
        if error_code in ['NotAuthorizedException', 'UserNotFoundException']:
            raise ValueError("Invalid email or password")
        else:
            print(f"Cognito error: {str(e)}")
            raise ValueError("Authentication service unavailable")


def authenticate_user(email: str, password: str) -> Dict[str, Any]:
    """
    Main authentication function that routes to appropriate backend.
    """
    print(f"Authenticating user {email} with mode: {AUTH_MODE}")

    if AUTH_MODE == 'cognito':
        return authenticate_user_cognito(email, password)
    elif AUTH_MODE == 'dynamodb':
        return authenticate_user_dynamodb(email, password)
    else:  # Default to mock
        return authenticate_user_mock(email, password)

def not_implemented_error(operation_name: str) -> Tuple[Dict[str, Any], int]:
    """Helper function for not-yet-implemented operations"""
    error_obj = Error(
        code="not_implemented",
        message=f"Operation {operation_name} not yet implemented",
        details={"operation": operation_name, "module": "auth"}
    )
    return error_obj.to_dict(), 501


def handle_auth_logout_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_logout_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_logout_post")


def handle_auth_post(body=None, *args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_post
    Authenticate user with email and password
    """
    try:
        # Extract credentials from request body
        if not body:
            return {"code": "missing_credentials", "message": "Missing request body"}, 400

        # Support both 'username' and 'email' fields for compatibility
        username = body.get('username') or body.get('email')
        password = body.get('password')

        if not username or not password:
            return {"code": "missing_credentials", "message": "Username and password required"}, 400

        # Authenticate user
        result = authenticate_user(username, password)
        return result, 200

    except ValueError as e:
        return {"code": "authentication_failed", "message": str(e), "details": {"error": "Authentication failed"}}, 401
    except Exception as e:
        return {"code": "server_error", "message": "Internal server error", "details": {"error": str(e)}}, 500


def handle_auth_refresh_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_refresh_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_refresh_post")


def handle_auth_reset_password_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_reset_password_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_reset_password_post")

