"""
Implementation module for auth
Auto-generated by post_openapi_generation.py
Enhanced with environment mode support and JWT utilities
"""

import os
import secrets
import logging
import boto3
import bcrypt
from typing import Any, Dict, List, Tuple, Union, Optional
from botocore.exceptions import ClientError
from ..models.error import Error
from .utils.jwt_utils import create_auth_response, generate_jwt_token
from .utils.error_handler import (
    bad_request_error,
    unauthorized_error,
    server_error,
    not_implemented_error as base_not_implemented_error
)
from .utils.password_policy import validate_password, get_password_policy_description

# Set up logging
logger = logging.getLogger(__name__)

# Environment configuration
AUTH_MODE = os.environ.get('AUTH_MODE', 'mock')
COGNITO_USER_POOL_ID = os.environ.get('COGNITO_USER_POOL_ID', '')
COGNITO_CLIENT_ID = os.environ.get('COGNITO_CLIENT_ID', '')
USERS_TABLE_NAME = os.environ.get('USERS_DYNAMO_TABLE_NAME', 'cmz-users-dev')

# Password hashing configuration
# bcrypt handles salt generation internally, making it more secure
# Cost factor for bcrypt (higher = more secure but slower)
BCRYPT_ROUNDS = int(os.environ.get('BCRYPT_ROUNDS', '12'))
if BCRYPT_ROUNDS < 10 and os.environ.get('ENVIRONMENT') == 'production':
    raise ValueError("BCRYPT_ROUNDS must be at least 10 in production")

# Log auth mode on module load
logger.info(f"ðŸ” Authentication Mode: {AUTH_MODE}")


def hash_password(password: str) -> str:
    """
    Hash a password using bcrypt with automatic salt generation.

    bcrypt is specifically designed for password hashing and is
    computationally expensive, making it resistant to brute force attacks.

    Args:
        password: Plain text password

    Returns:
        Hashed password as string (includes salt)
    """
    # bcrypt requires bytes
    password_bytes = password.encode('utf-8')
    # Generate salt and hash password
    hashed = bcrypt.hashpw(password_bytes, bcrypt.gensalt(rounds=BCRYPT_ROUNDS))
    # Return as string for storage
    return hashed.decode('utf-8')


def verify_password(stored_password: str, provided_password: str) -> bool:
    """
    Verify a password against a stored bcrypt hash.

    bcrypt handles salt extraction and verification internally,
    making it resistant to timing attacks and rainbow tables.

    Args:
        stored_password: Stored bcrypt hash
        provided_password: Password provided by user

    Returns:
        True if passwords match, False otherwise
    """
    try:
        # Convert strings to bytes for bcrypt
        stored_bytes = stored_password.encode('utf-8')
        provided_bytes = provided_password.encode('utf-8')

        # bcrypt.checkpw handles salt extraction and secure comparison
        return bcrypt.checkpw(provided_bytes, stored_bytes)
    except (ValueError, AttributeError):
        # Invalid hash format or encoding issues
        logger.warning("Invalid password hash format encountered")
        return False


def authenticate_user_mock(email: str, password: str) -> Dict[str, Any]:
    """
    Mock authentication for local development.
    Uses test users with pre-computed bcrypt hashes for security and performance.
    """
    # Test users with pre-computed bcrypt hashes
    # These are bcrypt hashes of the test passwords, pre-computed for performance
    # bcrypt is slow by design, so we pre-compute for test accounts
    # nosec B105 - These are test accounts for local development only
    test_users = {
        'admin@cmz.org': {
            # bcrypt hash of 'admin123' with cost factor 12
            'password_hash': '$2b$12$pwjfti2XGpto6Jz2RxDWC.SgB.PVcCm41aRK8hKMcMa/w8XijcftG',  # nosec nosemgrep - test account
            'role': 'admin'
        },
        'test@cmz.org': {
            # bcrypt hash of 'testpass123' with cost factor 12
            'password_hash': '$2b$12$YGVkDNPPHXUC/pKvQDrv4.bzLcXdFmRXZf7KgLaxmHvIlkxXNOhOq',  # nosec nosemgrep - test account
            'role': 'user'
        },
        'parent1@test.cmz.org': {
            # bcrypt hash of 'testpass123' with cost factor 12
            'password_hash': '$2b$12$YGVkDNPPHXUC/pKvQDrv4.bzLcXdFmRXZf7KgLaxmHvIlkxXNOhOq',  # nosec nosemgrep - test account
            'role': 'parent'
        },
        'student1@test.cmz.org': {
            # bcrypt hash of 'testpass123' with cost factor 12
            'password_hash': '$2b$12$YGVkDNPPHXUC/pKvQDrv4.bzLcXdFmRXZf7KgLaxmHvIlkxXNOhOq',  # nosec nosemgrep - test account
            'role': 'student'
        },
        'student2@test.cmz.org': {
            # bcrypt hash of 'testpass123' with cost factor 12
            'password_hash': '$2b$12$YGVkDNPPHXUC/pKvQDrv4.bzLcXdFmRXZf7KgLaxmHvIlkxXNOhOq',  # nosec nosemgrep - test account
            'role': 'student'
        },
        'user_parent_001@cmz.org': {
            # bcrypt hash of 'testpass123' with cost factor 12
            'password_hash': '$2b$12$YGVkDNPPHXUC/pKvQDrv4.bzLcXdFmRXZf7KgLaxmHvIlkxXNOhOq',  # nosec nosemgrep - test account
            'role': 'parent'
        }
    }

    # Check credentials using bcrypt verification
    if email not in test_users:
        raise ValueError("Invalid email or password")

    stored_hash = test_users[email]['password_hash']

    if not verify_password(stored_hash, password):
        raise ValueError("Invalid email or password")

    # Create user data
    user_data = {
        'email': email,
        'role': test_users[email]['role'],
        'user_id': email.replace('@', '_').replace('.', '_'),
        'auth_mode': 'mock'
    }

    return create_auth_response(user_data)


def authenticate_user_dynamodb(email: str, password: str) -> Dict[str, Any]:
    """
    Authenticate against DynamoDB users table.
    For staging/testing environments.
    """
    try:
        # Get user from DynamoDB
        dynamodb = boto3.resource('dynamodb')
        users_table = dynamodb.Table(USERS_TABLE_NAME)
        response = users_table.get_item(Key={'email': email})

        if 'Item' not in response:
            raise ValueError("Invalid email or password")

        user_item = response['Item']

        # Secure password verification using hashing
        stored_password = user_item.get('password', '')
        if not verify_password(stored_password, password):
            raise ValueError("Invalid email or password")

        # Create user data
        user_data = {
            'email': email,
            'role': user_item.get('role', 'user'),
            'user_id': user_item.get('userId', email.replace('@', '_').replace('.', '_')),
            'auth_mode': 'dynamodb'
        }

        return create_auth_response(user_data)

    except ClientError as e:
        logger.error(f"DynamoDB error: {str(e)}")
        raise ValueError("Authentication service unavailable")


def authenticate_user_cognito(email: str, password: str) -> Dict[str, Any]:
    """
    Authenticate against AWS Cognito.
    For production environments.
    """
    try:
        cognito_client = boto3.client('cognito-idp')

        # Initiate auth
        response = cognito_client.initiate_auth(
            ClientId=COGNITO_CLIENT_ID,
            AuthFlow='USER_PASSWORD_AUTH',
            AuthParameters={
                'USERNAME': email,
                'PASSWORD': password
            }
        )

        # Get user attributes
        user_response = cognito_client.get_user(
            AccessToken=response['AuthenticationResult']['AccessToken']
        )

        # Extract user attributes
        attributes = {attr['Name']: attr['Value'] for attr in user_response['UserAttributes']}

        # Create user data
        user_data = {
            'email': email,
            'role': attributes.get('custom:role', 'user'),
            'user_id': attributes.get('sub', email.replace('@', '_').replace('.', '_')),
            'auth_mode': 'cognito',
            'cognito_tokens': {
                'id_token': response['AuthenticationResult'].get('IdToken'),
                'access_token': response['AuthenticationResult'].get('AccessToken'),
                'refresh_token': response['AuthenticationResult'].get('RefreshToken')
            }
        }

        return create_auth_response(user_data)

    except ClientError as e:
        error_code = e.response['Error']['Code']
        if error_code in ['NotAuthorizedException', 'UserNotFoundException']:
            raise ValueError("Invalid email or password")
        else:
            logger.error(f"Cognito error: {str(e)}")
            raise ValueError("Authentication service unavailable")


def authenticate_user(email: str, password: str) -> Dict[str, Any]:
    """
    Main authentication function that routes to appropriate backend.
    """
    logger.debug(f"Authenticating user {email} with mode: {AUTH_MODE}")

    if AUTH_MODE == 'cognito':
        return authenticate_user_cognito(email, password)
    elif AUTH_MODE == 'dynamodb':
        return authenticate_user_dynamodb(email, password)
    else:  # Default to mock
        return authenticate_user_mock(email, password)

def not_implemented_error(operation_name: str) -> Tuple[Dict[str, Any], int]:
    """Helper function for not-yet-implemented operations"""
    return base_not_implemented_error(f"{operation_name} (auth)")


def handle_auth_logout_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_logout_post
    Implements PR003946-88: Return 204 No Content for logout
    """
    # Logout is successful, return 204 No Content
    return None, 204


def handle_auth_post(body=None, *args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_post
    Authenticate user with email and password
    """
    try:
        # Extract credentials from request body
        if not body:
            return bad_request_error("Missing request body")

        # Support both 'username' and 'email' fields for compatibility
        username = body.get('username') or body.get('email')
        password = body.get('password')

        if not username or not password:
            return bad_request_error("Username and password required")

        # Authenticate user
        result = authenticate_user(username, password)
        return result, 200

    except ValueError as e:
        # Don't leak specific error messages for security
        logger.error(f"Authentication failed: {str(e)}")
        return unauthorized_error("Invalid email or password")
    except Exception as e:
        # Log the actual error but don't expose it to the client
        logger.error(f"Authentication error: {str(e)}", exc_info=True)
        return server_error("An error occurred during authentication", exception=e)


def handle_auth_refresh_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_refresh_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_refresh_post")


def handle_auth_reset_password_post(body=None, *args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_reset_password_post
    Implements PR003946-87: Password policy enforcement
    """
    if not body:
        return bad_request_error("Request body is required")

    new_password = body.get('new_password')
    if not new_password:
        return bad_request_error("New password is required")

    # Validate password against policy (PR003946-87)
    is_valid, error_message = validate_password(new_password)
    if not is_valid:
        return bad_request_error(
            error_message,
            details={
                "field": "new_password",
                "policy": get_password_policy_description()
            }
        )

    # In a real implementation, we would:
    # 1. Verify the reset token
    # 2. Update the user's password in the database
    # 3. Invalidate the reset token

    # For now, return success response
    return {"message": "Password reset successful"}, 200

