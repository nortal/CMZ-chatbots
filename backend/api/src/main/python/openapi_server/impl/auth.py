"""
Implementation module for auth
Auto-generated by post_openapi_generation.py
Enhanced with environment mode support and JWT utilities
"""

import os
import hashlib
import hmac
import secrets
import logging
import boto3
from typing import Any, Dict, List, Tuple, Union, Optional
from botocore.exceptions import ClientError
from ..models.error import Error
from .utils.jwt_utils import create_auth_response, generate_jwt_token

# Set up logging
logger = logging.getLogger(__name__)

# Environment configuration
AUTH_MODE = os.environ.get('AUTH_MODE', 'mock')
COGNITO_USER_POOL_ID = os.environ.get('COGNITO_USER_POOL_ID', '')
COGNITO_CLIENT_ID = os.environ.get('COGNITO_CLIENT_ID', '')
USERS_TABLE_NAME = os.environ.get('USERS_DYNAMO_TABLE_NAME', 'cmz-users-dev')

# Password hashing configuration
# nosec B105 - Default value only for development, production check enforced
PASSWORD_SALT = os.environ.get('PASSWORD_SALT')
if not PASSWORD_SALT:
    if os.environ.get('ENVIRONMENT') == 'production':
        raise ValueError("PASSWORD_SALT must be set in production environment")
    # Generate a random salt for development (changes each run for security)
    PASSWORD_SALT = secrets.token_hex(32)  # nosec - dynamic generation for dev only
    logger.warning("Using dynamically generated password salt for development")

# Log auth mode on module load
logger.info(f"ðŸ” Authentication Mode: {AUTH_MODE}")


def hash_password(password: str) -> str:
    """
    Hash a password using HMAC-SHA256 with salt.

    Args:
        password: Plain text password

    Returns:
        Hashed password as hex string
    """
    return hmac.new(
        PASSWORD_SALT.encode(),
        password.encode(),
        hashlib.sha256
    ).hexdigest()


def verify_password(stored_password: str, provided_password: str) -> bool:
    """
    Verify a password against a stored hash.

    Args:
        stored_password: Stored password (hash or plain text for legacy)
        provided_password: Password provided by user

    Returns:
        True if passwords match, False otherwise
    """
    # For backward compatibility, check if stored password is hashed (64 chars hex)
    if len(stored_password) == 64 and all(c in '0123456789abcdef' for c in stored_password):
        # It's a hash, compare hashes securely
        return secrets.compare_digest(stored_password, hash_password(provided_password))
    else:
        # Legacy plain text - log warning and hash for comparison
        # nosec B105 - Backward compatibility for migration period only
        logger.warning(f"Plain text password detected for migration - user should update password")
        # Hash both sides for secure comparison even with plain text
        return secrets.compare_digest(hash_password(stored_password), hash_password(provided_password))


def authenticate_user_mock(email: str, password: str) -> Dict[str, Any]:
    """
    Mock authentication for local development.
    Uses test users with hashed passwords for security scanning compliance.
    """
    # Test users with hashed passwords (using hash_password for consistency)
    # These are pre-hashed versions of the test passwords for security scanning
    # nosec B105 - These are test accounts for local development only
    test_users = {
        'admin@cmz.org': {
            'password_hash': hash_password('admin123'),  # nosec - test account
            'role': 'admin'
        },
        'test@cmz.org': {
            'password_hash': hash_password('testpass123'),  # nosec - test account
            'role': 'user'
        },
        'parent1@test.cmz.org': {
            'password_hash': hash_password('testpass123'),  # nosec - test account
            'role': 'parent'
        },
        'student1@test.cmz.org': {
            'password_hash': hash_password('testpass123'),  # nosec - test account
            'role': 'student'
        },
        'student2@test.cmz.org': {
            'password_hash': hash_password('testpass123'),  # nosec - test account
            'role': 'student'
        },
        'user_parent_001@cmz.org': {
            'password_hash': hash_password('testpass123'),  # nosec - test account
            'role': 'parent'
        }
    }

    # Check credentials using secure comparison
    if email not in test_users:
        raise ValueError("Invalid email or password")

    stored_hash = test_users[email]['password_hash']
    provided_hash = hash_password(password)

    if not secrets.compare_digest(stored_hash, provided_hash):
        raise ValueError("Invalid email or password")

    # Create user data
    user_data = {
        'email': email,
        'role': test_users[email]['role'],
        'user_id': email.replace('@', '_').replace('.', '_'),
        'auth_mode': 'mock'
    }

    return create_auth_response(user_data)


def authenticate_user_dynamodb(email: str, password: str) -> Dict[str, Any]:
    """
    Authenticate against DynamoDB users table.
    For staging/testing environments.
    """
    try:
        # Get user from DynamoDB
        dynamodb = boto3.resource('dynamodb')
        users_table = dynamodb.Table(USERS_TABLE_NAME)
        response = users_table.get_item(Key={'email': email})

        if 'Item' not in response:
            raise ValueError("Invalid email or password")

        user_item = response['Item']

        # Secure password verification using hashing
        stored_password = user_item.get('password', '')
        if not verify_password(stored_password, password):
            raise ValueError("Invalid email or password")

        # Create user data
        user_data = {
            'email': email,
            'role': user_item.get('role', 'user'),
            'user_id': user_item.get('userId', email.replace('@', '_').replace('.', '_')),
            'auth_mode': 'dynamodb'
        }

        return create_auth_response(user_data)

    except ClientError as e:
        logger.error(f"DynamoDB error: {str(e)}")
        raise ValueError("Authentication service unavailable")


def authenticate_user_cognito(email: str, password: str) -> Dict[str, Any]:
    """
    Authenticate against AWS Cognito.
    For production environments.
    """
    try:
        cognito_client = boto3.client('cognito-idp')

        # Initiate auth
        response = cognito_client.initiate_auth(
            ClientId=COGNITO_CLIENT_ID,
            AuthFlow='USER_PASSWORD_AUTH',
            AuthParameters={
                'USERNAME': email,
                'PASSWORD': password
            }
        )

        # Get user attributes
        user_response = cognito_client.get_user(
            AccessToken=response['AuthenticationResult']['AccessToken']
        )

        # Extract user attributes
        attributes = {attr['Name']: attr['Value'] for attr in user_response['UserAttributes']}

        # Create user data
        user_data = {
            'email': email,
            'role': attributes.get('custom:role', 'user'),
            'user_id': attributes.get('sub', email.replace('@', '_').replace('.', '_')),
            'auth_mode': 'cognito',
            'cognito_tokens': {
                'id_token': response['AuthenticationResult'].get('IdToken'),
                'access_token': response['AuthenticationResult'].get('AccessToken'),
                'refresh_token': response['AuthenticationResult'].get('RefreshToken')
            }
        }

        return create_auth_response(user_data)

    except ClientError as e:
        error_code = e.response['Error']['Code']
        if error_code in ['NotAuthorizedException', 'UserNotFoundException']:
            raise ValueError("Invalid email or password")
        else:
            logger.error(f"Cognito error: {str(e)}")
            raise ValueError("Authentication service unavailable")


def authenticate_user(email: str, password: str) -> Dict[str, Any]:
    """
    Main authentication function that routes to appropriate backend.
    """
    logger.debug(f"Authenticating user {email} with mode: {AUTH_MODE}")

    if AUTH_MODE == 'cognito':
        return authenticate_user_cognito(email, password)
    elif AUTH_MODE == 'dynamodb':
        return authenticate_user_dynamodb(email, password)
    else:  # Default to mock
        return authenticate_user_mock(email, password)

def not_implemented_error(operation_name: str) -> Tuple[Dict[str, Any], int]:
    """Helper function for not-yet-implemented operations"""
    error_obj = Error(
        code="not_implemented",
        message=f"Operation {operation_name} not yet implemented",
        details={"operation": operation_name, "module": "auth"}
    )
    return error_obj.to_dict(), 501


def handle_auth_logout_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_logout_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_logout_post")


def handle_auth_post(body=None, *args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_post
    Authenticate user with email and password
    """
    try:
        # Extract credentials from request body
        if not body:
            return {"code": "missing_credentials", "message": "Missing request body"}, 400

        # Support both 'username' and 'email' fields for compatibility
        username = body.get('username') or body.get('email')
        password = body.get('password')

        if not username or not password:
            return {"code": "missing_credentials", "message": "Username and password required"}, 400

        # Authenticate user
        result = authenticate_user(username, password)
        return result, 200

    except ValueError as e:
        # Don't leak specific error messages for security
        logger.error(f"Authentication failed: {str(e)}")
        return {"code": "authentication_failed", "message": "Invalid email or password", "details": {"error": "Authentication failed"}}, 401
    except Exception as e:
        # Log the actual error but don't expose it to the client
        logger.error(f"Authentication error: {str(e)}", exc_info=True)
        return {"code": "server_error", "message": "Internal server error", "details": {"error": "An error occurred during authentication"}}, 500


def handle_auth_refresh_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_refresh_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_refresh_post")


def handle_auth_reset_password_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_reset_password_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_reset_password_post")

