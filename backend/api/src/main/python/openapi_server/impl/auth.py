"""
Implementation module for auth
Auto-generated by post_openapi_generation.py
Enhanced with environment mode support and JWT utilities
"""

import os
import hashlib
import hmac
import secrets
import logging
import boto3
from typing import Any, Dict, List, Tuple, Union, Optional
from botocore.exceptions import ClientError
from ..models.error import Error
from .utils.jwt_utils import create_auth_response, generate_jwt_token

# Set up logging
logger = logging.getLogger(__name__)

# Environment configuration
AUTH_MODE = os.environ.get('AUTH_MODE', 'mock')
COGNITO_USER_POOL_ID = os.environ.get('COGNITO_USER_POOL_ID', '')
COGNITO_CLIENT_ID = os.environ.get('COGNITO_CLIENT_ID', '')
USERS_TABLE_NAME = os.environ.get('USERS_DYNAMO_TABLE_NAME', 'cmz-users-dev')

# Password hashing configuration
PASSWORD_SALT = os.environ.get('PASSWORD_SALT', 'cmz-development-salt')
if PASSWORD_SALT == 'cmz-development-salt' and os.environ.get('ENVIRONMENT') == 'production':
    raise ValueError("PASSWORD_SALT must be set in production environment")

# Log auth mode on module load
logger.info(f"ðŸ” Authentication Mode: {AUTH_MODE}")


def hash_password(password: str) -> str:
    """
    Hash a password using HMAC-SHA256 with salt.

    Args:
        password: Plain text password

    Returns:
        Hashed password as hex string
    """
    return hmac.new(
        PASSWORD_SALT.encode(),
        password.encode(),
        hashlib.sha256
    ).hexdigest()


def verify_password(stored_password: str, provided_password: str) -> bool:
    """
    Verify a password against a stored hash.

    Args:
        stored_password: Stored password (hash or plain text for legacy)
        provided_password: Password provided by user

    Returns:
        True if passwords match, False otherwise
    """
    # For backward compatibility, check if stored password is hashed (64 chars hex)
    if len(stored_password) == 64 and all(c in '0123456789abcdef' for c in stored_password):
        # It's a hash, compare hashes
        return secrets.compare_digest(stored_password, hash_password(provided_password))
    else:
        # Legacy plain text - hash both for comparison (temporary backward compatibility)
        # In production, all passwords should be migrated to hashes
        return secrets.compare_digest(stored_password, provided_password)


def authenticate_user_mock(email: str, password: str) -> Dict[str, Any]:
    """
    Mock authentication for local development.
    Uses hardcoded test users.
    """
    # Test users for validation
    test_users = {
        'admin@cmz.org': {'password': 'admin123', 'role': 'admin'},
        'test@cmz.org': {'password': 'testpass123', 'role': 'user'},
        'parent1@test.cmz.org': {'password': 'testpass123', 'role': 'parent'},
        'student1@test.cmz.org': {'password': 'testpass123', 'role': 'student'},
        'student2@test.cmz.org': {'password': 'testpass123', 'role': 'student'},
        'user_parent_001@cmz.org': {'password': 'testpass123', 'role': 'parent'}
    }

    # Check credentials
    if email not in test_users or test_users[email]['password'] != password:
        raise ValueError("Invalid email or password")

    # Create user data
    user_data = {
        'email': email,
        'role': test_users[email]['role'],
        'user_id': email.replace('@', '_').replace('.', '_'),
        'auth_mode': 'mock'
    }

    return create_auth_response(user_data)


def authenticate_user_dynamodb(email: str, password: str) -> Dict[str, Any]:
    """
    Authenticate against DynamoDB users table.
    For staging/testing environments.
    """
    try:
        # Get user from DynamoDB
        dynamodb = boto3.resource('dynamodb')
        users_table = dynamodb.Table(USERS_TABLE_NAME)
        response = users_table.get_item(Key={'email': email})

        if 'Item' not in response:
            raise ValueError("Invalid email or password")

        user_item = response['Item']

        # Secure password verification using hashing
        stored_password = user_item.get('password', '')
        if not verify_password(stored_password, password):
            raise ValueError("Invalid email or password")

        # Create user data
        user_data = {
            'email': email,
            'role': user_item.get('role', 'user'),
            'user_id': user_item.get('userId', email.replace('@', '_').replace('.', '_')),
            'auth_mode': 'dynamodb'
        }

        return create_auth_response(user_data)

    except ClientError as e:
        logger.error(f"DynamoDB error: {str(e)}")
        raise ValueError("Authentication service unavailable")


def authenticate_user_cognito(email: str, password: str) -> Dict[str, Any]:
    """
    Authenticate against AWS Cognito.
    For production environments.
    """
    try:
        cognito_client = boto3.client('cognito-idp')

        # Initiate auth
        response = cognito_client.initiate_auth(
            ClientId=COGNITO_CLIENT_ID,
            AuthFlow='USER_PASSWORD_AUTH',
            AuthParameters={
                'USERNAME': email,
                'PASSWORD': password
            }
        )

        # Get user attributes
        user_response = cognito_client.get_user(
            AccessToken=response['AuthenticationResult']['AccessToken']
        )

        # Extract user attributes
        attributes = {attr['Name']: attr['Value'] for attr in user_response['UserAttributes']}

        # Create user data
        user_data = {
            'email': email,
            'role': attributes.get('custom:role', 'user'),
            'user_id': attributes.get('sub', email.replace('@', '_').replace('.', '_')),
            'auth_mode': 'cognito',
            'cognito_tokens': {
                'id_token': response['AuthenticationResult'].get('IdToken'),
                'access_token': response['AuthenticationResult'].get('AccessToken'),
                'refresh_token': response['AuthenticationResult'].get('RefreshToken')
            }
        }

        return create_auth_response(user_data)

    except ClientError as e:
        error_code = e.response['Error']['Code']
        if error_code in ['NotAuthorizedException', 'UserNotFoundException']:
            raise ValueError("Invalid email or password")
        else:
            logger.error(f"Cognito error: {str(e)}")
            raise ValueError("Authentication service unavailable")


def authenticate_user(email: str, password: str) -> Dict[str, Any]:
    """
    Main authentication function that routes to appropriate backend.
    """
    logger.debug(f"Authenticating user {email} with mode: {AUTH_MODE}")

    if AUTH_MODE == 'cognito':
        return authenticate_user_cognito(email, password)
    elif AUTH_MODE == 'dynamodb':
        return authenticate_user_dynamodb(email, password)
    else:  # Default to mock
        return authenticate_user_mock(email, password)

def not_implemented_error(operation_name: str) -> Tuple[Dict[str, Any], int]:
    """Helper function for not-yet-implemented operations"""
    error_obj = Error(
        code="not_implemented",
        message=f"Operation {operation_name} not yet implemented",
        details={"operation": operation_name, "module": "auth"}
    )
    return error_obj.to_dict(), 501


def handle_auth_logout_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_logout_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_logout_post")


def handle_auth_post(body=None, *args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_post
    Authenticate user with email and password
    """
    try:
        # Extract credentials from request body
        if not body:
            return {"code": "missing_credentials", "message": "Missing request body"}, 400

        # Support both 'username' and 'email' fields for compatibility
        username = body.get('username') or body.get('email')
        password = body.get('password')

        if not username or not password:
            return {"code": "missing_credentials", "message": "Username and password required"}, 400

        # Authenticate user
        result = authenticate_user(username, password)
        return result, 200

    except ValueError as e:
        return {"code": "authentication_failed", "message": str(e), "details": {"error": "Authentication failed"}}, 401
    except Exception as e:
        return {"code": "server_error", "message": "Internal server error", "details": {"error": str(e)}}, 500


def handle_auth_refresh_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_refresh_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_refresh_post")


def handle_auth_reset_password_post(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for auth_reset_password_post

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("auth_reset_password_post")

