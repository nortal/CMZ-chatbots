#!/usr/bin/env python3
"""
Post-OpenAPI Generation Script
Ensures all controllers are properly connected to implementation modules
Runs automatically after OpenAPI code generation
"""

import re
import sys
from pathlib import Path
from typing import Dict, List, Set

def analyze_generated_controllers(controllers_dir: Path) -> Dict[str, List[str]]:
    """Analyze generated controllers to identify connection opportunities"""
    controller_functions = {}

    for controller_file in controllers_dir.glob("*_controller.py"):
        controller_name = controller_file.stem
        functions = []

        try:
            with open(controller_file, 'r') as f:
                content = f.read()

            # Find function definitions
            function_matches = re.findall(r'def (\w+)\([^)]*\):', content)

            for func_name in function_matches:
                if func_name != '__init__':
                    functions.append(func_name)

            controller_functions[controller_name] = functions

        except Exception as e:
            print(f"Warning: Could not analyze {controller_file}: {e}")

    return controller_functions

def ensure_implementation_modules(impl_dir: Path, controller_functions: Dict[str, List[str]]) -> None:
    """Ensure implementation modules exist with proper handler functions"""

    for controller_name, functions in controller_functions.items():
        # Map controller names to implementation modules
        impl_module_name = controller_name.replace('_controller', '')
        impl_file = impl_dir / f"{impl_module_name}.py"

        if not impl_file.exists():
            print(f"Creating NEW implementation module: {impl_file}")
            # Only create stub file if it doesn't exist at all
            create_impl_module(impl_file, impl_module_name, functions)
        else:
            print(f"Implementation module EXISTS (preserving): {impl_file}")
            # NEVER overwrite existing implementations
            # Only add missing handler functions if needed
            ensure_handler_functions(impl_file, functions)

def create_impl_module(impl_file: Path, module_name: str, functions: List[str]) -> None:
    """Create a new implementation module with handler function stubs

    CRITICAL: This function should ONLY be called for non-existent files.
    Never overwrite existing implementations!
    """

    # CRITICAL SAFETY CHECK - Never overwrite critical implementation files
    critical_files = ['auth.py', 'handlers.py', 'animals.py', 'family.py', 'users.py']
    if impl_file.name in critical_files and impl_file.exists():
        print(f"‚ö†Ô∏è  CRITICAL: Refusing to overwrite existing {impl_file.name} - preserving implementation")
        return

    # Additional safety check
    if impl_file.exists():
        print(f"‚ö†Ô∏è  WARNING: File {impl_file} already exists - skipping to preserve implementation")
        return

    content = f'''"""
Implementation module for {module_name}
Auto-generated by post_openapi_generation.py
"""

from typing import Any, Dict, List, Tuple, Union
from ..models.error import Error


def not_implemented_error(operation_name: str) -> Tuple[Dict[str, Any], int]:
    """Helper function for not-yet-implemented operations"""
    error_obj = Error(
        code="not_implemented",
        message=f"Operation {{operation_name}} not yet implemented",
        details={{"operation": operation_name, "module": "{module_name}"}}
    )
    return error_obj.to_dict(), 501

'''

    # UI module mapping: controller function names ‚Üí domain function names
    # handlers.py imports these exact function names from ui.py
    ui_function_map = {
        'root_get': 'homepage_get',
        'admin_get': 'admin_dashboard_get',
        'member_get': 'member_dashboard_get'
    }

    for func_name in functions:
        # Special handling for UI module - use domain function names without handle_ prefix
        if module_name == 'ui' and func_name in ui_function_map:
            handler_name = ui_function_map[func_name]
            print(f"  ‚úì UI module: Generating {handler_name} (mapped from {func_name})")
        else:
            # Standard pattern: add handle_ prefix for other modules
            handler_name = f"handle_{func_name}"

        content += f'''
def {handler_name}(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for {func_name}

    TODO: Implement business logic for this operation
    """
    return not_implemented_error("{func_name}")

'''

    # Create parent directories if they don't exist
    impl_file.parent.mkdir(parents=True, exist_ok=True)

    with open(impl_file, 'w') as f:
        f.write(content)

def ensure_handler_functions(impl_file: Path, functions: List[str]) -> None:
    """Ensure all required handler functions exist in the implementation module"""

    try:
        with open(impl_file, 'r') as f:
            content = f.read()
    except Exception as e:
        print(f"Warning: Could not read {impl_file}: {e}")
        return

    # UI module mapping: controller function names ‚Üí domain function names
    ui_function_map = {
        'root_get': 'homepage_get',
        'admin_get': 'admin_dashboard_get',
        'member_get': 'member_dashboard_get'
    }

    module_name = impl_file.stem  # Get module name from filename (e.g., 'ui' from 'ui.py')
    missing_handlers = []

    for func_name in functions:
        # Special handling for UI module - use domain function names without handle_ prefix
        if module_name == 'ui' and func_name in ui_function_map:
            handler_name = ui_function_map[func_name]
            print(f"  ‚úì Checking UI function: {handler_name} (mapped from {func_name})")
        else:
            # Standard pattern: add handle_ prefix for other modules
            handler_name = f"handle_{func_name}"

        if f"def {handler_name}" not in content:
            missing_handlers.append((handler_name, func_name))

    if missing_handlers:
        handler_names = [h[0] for h in missing_handlers]
        print(f"Adding missing handlers to {impl_file}: {', '.join(handler_names)}")

        # Add missing handler functions
        additional_content = "\n# Auto-generated handler functions\n"

        for handler_name, func_name in missing_handlers:
            additional_content += f'''
def {handler_name}(*args, **kwargs) -> Tuple[Any, int]:
    """
    Implementation handler for {func_name}

    TODO: Implement business logic for this operation
    """
    from ..models.error import Error
    error_obj = Error(
        code="not_implemented",
        message=f"Operation {func_name} not yet implemented",
        details={{"operation": "{func_name}", "handler": "{handler_name}"}}
    )
    return error_obj.to_dict(), 501

'''

        with open(impl_file, 'a') as f:
            f.write(additional_content)

def update_makefile_integration() -> None:
    """Update Makefile to include post-generation script"""
    makefile_path = Path("Makefile")

    if not makefile_path.exists():
        print("Warning: Makefile not found, skipping integration")
        return

    try:
        with open(makefile_path, 'r') as f:
            content = f.read()
    except Exception as e:
        print(f"Warning: Could not read Makefile: {e}")
        return

    # Check if post-generation script is already integrated
    if "post_openapi_generation.py" in content:
        print("Makefile already integrated with post-generation script")
        return

    # Add post-generation step after sync-openapi
    if "sync-openapi:" in content:
        updated_content = content.replace(
            'echo "=== Done: sync-openapi ==="',
            '''echo "=== Done: sync-openapi ==="
\t@echo "--- Running post-generation setup..."
\tpython3 scripts/post_openapi_generation.py $(SRC_APP_DIR)
\t@echo "=== Done: post-generation setup ==="'''
        )

        with open(makefile_path, 'w') as f:
            f.write(updated_content)

        print("Updated Makefile to include post-generation script")

def main():
    if len(sys.argv) != 2:
        print("Usage: post_openapi_generation.py <source_app_dir>")
        sys.exit(1)

    source_app_dir = Path(sys.argv[1])
    controllers_dir = source_app_dir / "openapi_server" / "controllers"
    impl_dir = source_app_dir / "openapi_server" / "impl"

    print("üîß Running Post-OpenAPI Generation Setup...")

    if not controllers_dir.exists():
        print(f"Error: Controllers directory not found: {controllers_dir}")
        sys.exit(1)

    # Analyze generated controllers
    print(f"üìã Analyzing controllers in {controllers_dir}")
    controller_functions = analyze_generated_controllers(controllers_dir)

    print(f"Found {len(controller_functions)} controllers with {sum(len(funcs) for funcs in controller_functions.values())} functions")

    # Ensure implementation modules exist
    print(f"üèóÔ∏è Ensuring implementation modules in {impl_dir}")
    ensure_implementation_modules(impl_dir, controller_functions)

    # Update Makefile integration
    print("üìù Updating Makefile integration")
    update_makefile_integration()

    print("‚úÖ Post-generation setup completed successfully!")

if __name__ == "__main__":
    main()