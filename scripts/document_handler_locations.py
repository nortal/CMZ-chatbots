#!/usr/bin/env python3
"""
Document Handler Locations Script
Verifies and documents where each handler implementation actually exists
"""

import os
import re
from pathlib import Path

def find_function_location(func_name, impl_dir):
    """Find where a function is actually implemented"""
    locations = []

    for root, dirs, files in os.walk(impl_dir):
        for file in files:
            if file.endswith('.py'):
                filepath = os.path.join(root, file)
                try:
                    with open(filepath, 'r') as f:
                        content = f.read()
                        # Look for function definition
                        if f"def {func_name}" in content:
                            # Get relative path from impl dir
                            rel_path = os.path.relpath(filepath, impl_dir)

                            # Check what the function does
                            lines = content.split('\n')
                            for i, line in enumerate(lines):
                                if f"def {func_name}" in line:
                                    # Look at next few lines for clues
                                    func_body = '\n'.join(lines[i:i+10])

                                    # Determine implementation type
                                    impl_type = "Unknown"
                                    if "DynamoDB" in func_body or "table" in func_body.lower():
                                        impl_type = "DynamoDB"
                                    elif "mock" in func_body.lower():
                                        impl_type = "Mock"
                                    elif "not_implemented" in func_body:
                                        impl_type = "Stub"
                                    elif "return {" in func_body:
                                        impl_type = "Static"
                                    elif "import" in func_body and "from ." in func_body:
                                        # Check if it's a redirect
                                        import_match = re.search(r'from \.([\w_]+) import ([\w_]+)', func_body)
                                        if import_match:
                                            impl_type = f"→{import_match.group(1)}.py"

                                    locations.append({
                                        'file': rel_path,
                                        'type': impl_type,
                                        'line': i + 1
                                    })
                                    break
                except Exception as e:
                    print(f"Error reading {filepath}: {e}")

    return locations

def main():
    impl_dir = Path("backend/api/src/main/python/openapi_server/impl")
    handlers_file = impl_dir / "handlers.py"

    # Read handlers.py to get the handler_map
    with open(handlers_file, 'r') as f:
        content = f.read()

    # Extract handler_map entries
    map_pattern = r"'(\w+)':\s*(handle_\w+)"
    mappings = re.findall(map_pattern, content)

    print("=" * 60)
    print("Handler Location Documentation")
    print("=" * 60)

    documented_mappings = []

    for operation_id, handler_func in mappings:
        # Find where the handler is implemented
        locations = find_function_location(handler_func, str(impl_dir))

        if locations:
            loc = locations[0]  # Take first match
            comment = f"# → {loc['file']}:{handler_func}() [{loc['type']}]"
            documented_mappings.append(f"            '{operation_id}': {handler_func},  {comment}")
            print(f"✅ {operation_id} → {handler_func}")
            print(f"   Location: {loc['file']} (line {loc['line']}) [{loc['type']}]")
        else:
            # Function not found - mark as missing
            comment = f"# ❌ MISSING IMPLEMENTATION"
            documented_mappings.append(f"            '{operation_id}': {handler_func},  {comment}")
            print(f"❌ {operation_id} → {handler_func}")
            print(f"   NOT FOUND - Needs implementation")
        print()

    # Write documented version
    output_file = impl_dir / "handler_map_documented.py"
    with open(output_file, 'w') as f:
        f.write("# Documented Handler Map\n")
        f.write("# Generated by document_handler_locations.py\n\n")
        f.write("handler_map = {\n")
        for mapping in documented_mappings:
            f.write(mapping + "\n")
        f.write("}\n")

    print(f"\n✅ Documented handler map written to: {output_file}")
    print("\nNext steps:")
    print("1. Review the documented map")
    print("2. Replace the handler_map in handlers.py with the documented version")
    print("3. Implement any missing handlers marked with ❌")

if __name__ == "__main__":
    main()